import os
import logging
from io import BytesIO
import pandas as pd
from pathlib import Path
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from dotenv import load_dotenv
from datetime import datetime, timedelta
from collections import defaultdict, deque
import re
from modules import (
    LLMProcessor, QueryType,
    ChartGenerator
)
from modules.llm_processor import ChartType, QueryParameters
from modules.data_query import DataFrameManager
from modules.classifier import Classifier

load_dotenv()
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)
LOG_FILE = Path(os.getenv("BOT_LOG_FILE", "conversazioni_bot.csv"))
HELP_TEXT = (
    "**Come usare il bot**\n\n"
    "Scrivimi una domanda sui dati socio‚Äëeconomici comunali.\n\n"
    "**Esempi**\n"
    "- Popolazione di Milano e Roma\n"
    "- Pensionati Napoli e Milano rispetto alla popolazione 2015‚Äë2023\n"
    "- Quota reddito da lavoro dipendente su totale Roma, Milano\n"
    "- Ricchezza media Torino 2010‚Äë2020\n\n"
    "**Comandi**\n"
    "/start ¬∑ /help ¬∑ /info ¬∑ /plot"
)
INFO_TEXT = (
    "**Informazioni sul Bot**\n\n"
    "Autore: Giulio Albano (Univ. Bari, tirocinio Banca d'Italia)\n"
    "Fonti: ISTAT, MEF, MIUR, Infocamere, Eurostat\n"
    "Il bot normalizza i dati, calcola metriche derivate (pro capite, quote, crescite) e genera grafici leggibili."
)
MAX_REQUESTS_PER_MINUTE = 5
MAX_NONSENSE = 5
BLOCK_DURATION = timedelta(minutes=30)
user_requests = defaultdict(deque)
user_nonsense = defaultdict(int)
user_blocked = {}

def log_message(user, message_text, message_type, direction="IN", query_type=None, comuni=None, metrics=None):
    clean_text = message_text.encode("utf-8","ignore").decode("utf-8") if message_text else ""
    clean_text = clean_text.replace("\n"," ").replace("\r"," ").replace('"',"'")
    rec = {
        "timestamp": pd.Timestamp.now(),
        "user_id": user.id,
        "username": user.username or user.first_name,
        "first_name": user.first_name,
        "last_name": user.last_name or "",
        "direction": direction,
        "message_type": message_type,
        "message_text": clean_text,
        "query_type": query_type or "",
        "comuni": ",".join(comuni) if comuni else "",
        "metrics": ",".join(metrics) if metrics else "",
        "character_count": len(clean_text),
        "word_count": len(clean_text.split()) if clean_text else 0
    }
    df = pd.DataFrame([rec])
    try:
        if LOG_FILE.exists():
            df.to_csv(LOG_FILE, mode="a", header=False, index=False, encoding="utf-8-sig")
        else:
            df.to_csv(LOG_FILE, mode="w", header=True, index=False, encoding="utf-8-sig")
    except Exception as e:
        logger.error(f"log save error: {e}")

def is_user_blocked(user_id: int) -> bool:
    if user_id in user_blocked:
        if datetime.now() < user_blocked[user_id]:
            return True
        else:
            del user_blocked[user_id]
            user_nonsense[user_id] = 0
    return False

def register_request(user_id: int) -> bool:
    now = datetime.now()
    dq = user_requests[user_id]
    while dq and (now - dq[0]).seconds > 60:
        dq.popleft()
    dq.append(now)
    if len(dq) > MAX_REQUESTS_PER_MINUTE:
        user_blocked[user_id] = now + BLOCK_DURATION
        return False
    return True

def is_nonsense_message(message: str) -> bool:
    s = (message or "").strip().lower()
    if len(s) < 2: return True
    if re.match(r"^[^\w\s]+$", s) or re.match(r"^\d+$", s): return True
    if re.match(r"^(.)\1{4,}$", s): return True
    if re.match(r"^[a-z]{10,}$", s) and not any(v in s for v in "aeiou"): return True
    return False

class SocioEconomicBot:
    def __init__(self, token: str):
        self.token = token
        self.application = None
        self.df_manager = DataFrameManager(data_dir=os.getenv("DATA_DIR", r"resources"))
        self.chart_generator = ChartGenerator()
        openai_key = os.getenv("OPENAI_API_KEY")
        self.classifier = Classifier(openai_key) if openai_key else None
        self.llm_processor = LLMProcessor(openai_key) if openai_key else None
        self.main_keyboard = ReplyKeyboardMarkup(
            [[KeyboardButton("/start"), KeyboardButton("/help")],
             [KeyboardButton("/info"), KeyboardButton("/plot")]],
            resize_keyboard=True, is_persistent=True
        )

    def _infer_comuni_from_text(self, text: str) -> list:
        try:
            # Rileva richiesta di analisi socio-economica multi-comune
            tlow = (text or "").lower()
            if any(k in tlow for k in [
                'analisi socio', 'indagine generale', 'indagine gener', 'analisi generale',
                'analisi comparativa', 'analisi confronto', 'aiutami a comparare',
                'compara', 'comparare', 'confronta', 'confronto']):
                # Questo metodo deve solo inferire comuni, non inviare messaggi
                # L'azione di overview viene gestita in plot_command
                pass
            import difflib
            t = (text or "").lower()
            en_map = {
                'milan':'milano', 'rome':'roma', 'naples':'napoli', 'turin':'torino', 'florence':'firenze',
                'venice':'venezia', 'bologna':'bologna', 'genoa':'genova', 'bari':'bari', 'catania':'catania',
                'palermo':'palermo', 'verona':'verona', 'padua':'padova', 'trieste':'trieste', 'brescia':'brescia',
            }
            for en,it in en_map.items():
                if en in t:
                    return [it]
            if getattr(self.df_manager, 'df', None) is None or 'comune' not in self.df_manager.df.columns:
                return []
            comuni_unique = sorted({str(c).strip().lower() for c in self.df_manager.df['comune'].dropna().unique()})
            tokens = [w for w in re.split(r"[^\w√†√®√©√¨√≤√≥√π]+", t) if len(w) >= 3]
            matches = set()
            for tok in tokens:
                if tok in comuni_unique:
                    matches.add(tok)
                    continue
                close = difflib.get_close_matches(tok, comuni_unique, n=1, cutoff=0.8)
                if close:
                    matches.add(close[0])
            return list(matches)
        except Exception:
            return []

    def setup(self):
        self.application = Application.builder().token(self.token).build()
        try:
            self.df_manager.load_data()
        except Exception as e:
            logger.error(f"Errore caricamento dati: {e}")
        self._register_handlers()

    def _register_handlers(self):
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("info", self.info_command))
        self.application.add_handler(CommandHandler("plot", self.plot_command))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_question))

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        msg = (f"Ciao {user.first_name}!\n\n"
               "Sono il bot per informazioni socio-economiche comunali. "
               "Scrivimi una richiesta (es. 'pensionati Napoli e Milano rispetto alla popolazione 2015-2023') "
               "oppure usa /help per esempi.")
        await update.message.reply_text(msg, reply_markup=self.main_keyboard)
        log_message(user, msg, "RESPONSE", "OUT", query_type="START")

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        msg = ("üìä **Come usare il bot:**\n\n"
               "Scrivimi una domanda sui dati socio-economici comunali.\n\n"
               "**Esempi:**\n"
               "‚Ä¢ Popolazione di Milano e Roma\n"
               "‚Ä¢ Pensionati Napoli e Milano rispetto alla popolazione 2015-2023\n"
               "‚Ä¢ Quota reddito da lavoro dipendente su totale Roma, Milano\n"
               "‚Ä¢ Ricchezza media Torino 2010-2020\n\n"
               "**Comandi:**\n"
               "/start ‚Ä¢ /help ‚Ä¢ /info ‚Ä¢ /plot")
        # Sovrascrive il messaggio con testo pulito e aggiunge elenco variabili
        msg = HELP_TEXT
        try:
            if self.llm_processor:
                vars = self.llm_processor.available_variables(limit=20)
                if vars:
                    msg += "\n\n**Variabili disponibili (parziale)**\n" + ", ".join(f"`{v}`" for v in vars)
        except Exception:
            pass
        await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=self.main_keyboard)
        log_message(user, msg, "RESPONSE", "OUT", query_type="HELP")

    async def info_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        msg = ("‚ÑπÔ∏è **Informazioni sul Bot**\n\n"
               "Autore: Giulio Albano (Univ. Bari, tirocinio Banca d'Italia)\n"
               "Fonti: ISTAT, MEF, MIUR, Infocamere, Eurostat\n"
               "Il bot normalizza i dati, calcola metriche derivate (pro capite, quote, crescite) e genera grafici leggibili.")
        msg = INFO_TEXT
        await update.message.reply_text(msg, parse_mode='Markdown', reply_markup=self.main_keyboard)
        log_message(user, msg, "RESPONSE", "OUT", query_type="INFO")

    async def handle_question(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        text = update.message.text.strip()
        # Classificazione del messaggio (se disponibile)
        try:
            if self.classifier:
                res = self.classifier.classify(text)
                cat = res.get('category')
                if cat == 'help_request':
                    await self.help_command(update, context)
                    return
                if cat == 'info_request':
                    await self.info_command(update, context)
                    return
                if cat == 'offensive':
                    await update.message.reply_text("Per favore usa un linguaggio rispettoso.")
                    return
                if cat == 'nonsense':
                    await update.message.reply_text("Messaggio non riconosciuto. Usa /help per esempi.")
                    return
        except Exception:
            pass
        if is_user_blocked(user.id):
            await update.message.reply_text("üö´ Sei temporaneamente bloccato. Riprova tra 30 minuti.")
            return
        if not register_request(user.id):
            await update.message.reply_text("üö´ Troppe richieste. Riprova tra 30 minuti.")
            return
        if is_nonsense_message(text):
            user_nonsense[user.id] += 1
            if user_nonsense[user.id] >= MAX_NONSENSE:
                user_blocked[user.id] = datetime.now() + BLOCK_DURATION
                await update.message.reply_text("üö´ Messaggi non validi. Riprova tra 30 minuti.")
            else:
                await update.message.reply_text("‚ö†Ô∏è Messaggio non riconosciuto. Usa /help per esempi.")
            return
        await self.plot_command(update, context, user_input=text)

    async def plot_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE, user_input: str = None):
        user = update.effective_user
        text = user_input or " ".join(context.args)
        if not text:
            await update.message.reply_text("‚ùì Usa `/plot popolazione Milano` o simili.", parse_mode="Markdown")
            return
        processing_msg = await update.message.reply_text("üîÑ Elaborazione in corso...")
        try:
            if self.llm_processor is None:
                await processing_msg.edit_text("‚ùå LLM non configurato. Aggiungi OPENAI_API_KEY nel .env")
                return
            params = self.llm_processor.process_request(text)
            logger.info(f"Richiesta parsata: query={getattr(params.query_type,'value',params.query_type)}, comuni={params.comuni}, metrics={params.metrics}, anno={params.anno}, range={params.start_year}-{params.end_year}")
            df, xlabel, ylabel = self.df_manager.query_data(params)
            # Se il LLM non ha trovato comuni, prova a inferirli dal testo e rifai la query
            if not getattr(params, 'comuni', None):
                inferred = self._infer_comuni_from_text(text)
                if inferred:
                    params.comuni = inferred
                    logger.info(f"Comuni inferiti dal testo: {inferred}")
                    df, xlabel, ylabel = self.df_manager.query_data(params)
            # Se l'utente menziona grafici a linea/andamento, preferisci line
            tl = text.lower()
            if ('line' in tl or 'linea' in tl or 'andamento' in tl or 'nel tempo' in tl or 'storico' in tl or 'evoluzione' in tl):
                try:
                    from modules.llm_processor import ChartType
                    params.chart_type = ChartType.LINE
                except Exception:
                    pass
            # Forza line per serie storica
            try:
                if getattr(params.query_type, 'value', params.query_type) == 'time_series' or ('nel tempo' in tl):
                    from modules.llm_processor import ChartType
                    params.chart_type = ChartType.LINE
            except Exception:
                pass
            # Per serie storiche senza periodo esplicito: mostra serie massima e trimma zeri iniziali
            try:
                qtv = getattr(params.query_type, 'value', params.query_type)
            except Exception:
                qtv = None
            if qtv == 'time_series' and 'anno' in df.columns:
                df = self._trim_leading_zeros(df, x_col='anno')
            if df is None or df.empty:
                await processing_msg.edit_text("‚ùå Nessun dato trovato.")
                return
            # Costruisci titolo leggibile
            if (not params.metrics) and ('popola' in tl or 'abitant' in tl):
                params.metrics = ['pop_totale']
            metrics_label = ' / '.join(params.metrics or [])
            comuni_label = ", ".join(params.comuni) if params.comuni else "(tutti i comuni)"
            if params.anno:
                period_label = str(params.anno)
            elif params.start_year and params.end_year:
                period_label = f"{params.start_year}-{params.end_year}"
            else:
                # Nessun periodo esplicito: per serie storiche mostra range effettivo
                if qtv == 'time_series' and 'anno' in df.columns and df['anno'].notna().any():
                    try:
                        ymin = int(pd.to_numeric(df['anno'], errors='coerce').dropna().min())
                        ymax = int(pd.to_numeric(df['anno'], errors='coerce').dropna().max())
                        period_label = f"{ymin}-{ymax}" if ymin != ymax else f"{ymin}"
                    except Exception:
                        period_label = ""
                else:
                    period_label = ""
            parts = [metrics_label, comuni_label]
            if period_label:
                parts.append(period_label)
            title = " - ".join([p for p in parts if p])
            img = self.chart_generator.generate_chart(
                df, chart_type=(getattr(params.chart_type, 'value', params.chart_type)), title=title, xlabel=xlabel, ylabel=ylabel
            )
            comment = ""
            try:
                if self.llm_processor:
                    comment = self.llm_processor.generate_commentary(df, params)
            except Exception:
                comment = ""
            await update.message.reply_photo(BytesIO(img), caption=title, reply_markup=self.main_keyboard)
            if comment:
                await update.message.reply_text(comment)

        # Analisi comparativa disattivata in questa release (pulizia errori)

        except Exception as e:
            logger.exception("Errore nella generazione del grafico")
            await processing_msg.edit_text("ÔøΩ?O Errore durante l'elaborazione. Riprova.")
            log_message(user, str(e), "ERROR", "OUT")

    def run(self):
        if not self.application:
            self.setup()
        logger.info("Bot in esecuzione...")
        self.application.run_polling(drop_pending_updates=True, allowed_updates=Update.ALL_TYPES)

def main():
    TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    if not TOKEN:
        logger.error("Token mancante. Imposta TELEGRAM_BOT_TOKEN nel .env")
        return
    bot = SocioEconomicBot(TOKEN)
    try:
        bot.run()
    except KeyboardInterrupt:
        logger.info("Bot arrestato dall'utente")
    except Exception as e:
        logger.error(f"Errore critico: {e}")

if __name__ == "__main__":
    main()


 

