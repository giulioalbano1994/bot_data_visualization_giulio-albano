import os
import logging
from io import BytesIO
import pandas as pd
from pathlib import Path
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from dotenv import load_dotenv
from datetime import datetime, timedelta
from collections import defaultdict, deque
import re
from modules import (
    LLMProcessor, QueryType,
    ChartGenerator
)
from modules.llm_processor import ChartType, QueryParameters
from modules.data_query import DataFrameManager
from modules.classifier import Classifier

# ---------- Config ----------
load_dotenv()
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

LOG_FILE = Path(os.getenv("BOT_LOG_FILE", "conversazioni_bot.csv"))

HELP_TEXT = (
    "ðŸ“Š **Come usare il bot**\n\n"
    "Scrivimi una domanda sui dati socio-economici comunali.\n\n"
    "âœ¨ **Esempi utili**:\n"
    "- ðŸ‘¥ Popolazione di *Milano* e *Roma*\n"
    "- ðŸ‘©â€ðŸ¦³ Pensionati a *Napoli* e *Milano* rispetto alla popolazione (2015-2023)\n"
    "- ðŸ’¼ Reddito medio a *Torino* nel tempo\n"
    "- ðŸ“ˆ Gini index a *Bari* e *Palermo*\n"
    "- ðŸŽ“ Laureati residenti a *Firenze* e *Bologna* (ultimo anno disponibile)\n\n"
    "âš™ï¸ **Comandi rapidi**:\n"
    "â€¢ /start â†’ messaggio di benvenuto\n"
    "â€¢ /help â†’ questa guida\n"
    "â€¢ /info â†’ informazioni sul bot\n"
    "â€¢ /plot â†’ genera un grafico a partire da una query\n"
)

INFO_TEXT = (
    "â„¹ï¸ **Informazioni sul Bot**\n\n"
    "ðŸ‘¨â€ðŸ’» Autore: *Giulio Albano* (Univ. Bari, tirocinio Banca d'Italia)\n"
    "ðŸ“š Fonti: *ISTAT, MEF, MIUR, Infocamere, Eurostat*\n\n"
    "ðŸ”Ž Il bot normalizza i dati, calcola metriche derivate "
    "(pro capite, percentuali, quote, crescite) e genera grafici leggibili. "
    "Perfetto per confronti tra comuni, serie storiche e analisi distributive."
)

# Limiti e blocchi
MAX_REQUESTS_PER_MINUTE = 5
MAX_NONSENSE = 5
BLOCK_DURATION = timedelta(minutes=30)
user_requests = defaultdict(deque)
user_nonsense = defaultdict(int)
user_blocked = {}

# ---------- Funzioni utility ----------

def log_message(user, message_text, message_type, direction="IN", query_type=None, comuni=None, metrics=None):
    clean_text = message_text.encode("utf-8","ignore").decode("utf-8") if message_text else ""
    clean_text = clean_text.replace("\n"," ").replace("\r"," ").replace('"',"'")
    rec = {
        "timestamp": pd.Timestamp.now(),
        "user_id": user.id,
        "username": user.username or user.first_name,
        "first_name": user.first_name,
        "last_name": user.last_name or "",
        "direction": direction,
        "message_type": message_type,
        "message_text": clean_text,
        "query_type": query_type or "",
        "comuni": ",".join(comuni) if comuni else "",
        "metrics": ",".join(metrics) if metrics else "",
        "character_count": len(clean_text),
        "word_count": len(clean_text.split()) if clean_text else 0
    }
    df = pd.DataFrame([rec])
    try:
        if LOG_FILE.exists():
            df.to_csv(LOG_FILE, mode="a", header=False, index=False, encoding="utf-8-sig")
        else:
            df.to_csv(LOG_FILE, mode="w", header=True, index=False, encoding="utf-8-sig")
    except Exception as e:
        logger.error(f"log save error: {e}")

def is_user_blocked(user_id: int) -> bool:
    if user_id in user_blocked:
        if datetime.now() < user_blocked[user_id]:
            return True
        else:
            del user_blocked[user_id]
            user_nonsense[user_id] = 0
    return False

def register_request(user_id: int) -> bool:
    now = datetime.now()
    dq = user_requests[user_id]
    while dq and (now - dq[0]).seconds > 60:
        dq.popleft()
    dq.append(now)
    if len(dq) > MAX_REQUESTS_PER_MINUTE:
        user_blocked[user_id] = now + BLOCK_DURATION
        return False
    return True

def is_nonsense_message(message: str) -> bool:
    s = (message or "").strip().lower()
    if len(s) < 2: return True
    if re.match(r"^[^\w\s]+$", s) or re.match(r"^\d+$", s): return True
    if re.match(r"^(.)\1{4,}$", s): return True
    if re.match(r"^[a-z]{10,}$", s) and not any(v in s for v in "aeiou"): return True
    return False

# ---------- Classe principale ----------

class SocioEconomicBot:
    def __init__(self, token: str):
        self.token = token
        self.application = None
        self.df_manager = DataFrameManager(data_dir=os.getenv("DATA_DIR", r"resources"))
        self.chart_generator = ChartGenerator()
        openai_key = os.getenv("OPENAI_API_KEY")
        self.classifier = Classifier(openai_key) if openai_key else None
        self.llm_processor = LLMProcessor(openai_key) if openai_key else None
        self.main_keyboard = ReplyKeyboardMarkup(
            [[KeyboardButton("/start"), KeyboardButton("/help")],
             [KeyboardButton("/info"), KeyboardButton("/plot")]],
            resize_keyboard=True, is_persistent=True
        )

    # ---------- Setup ----------
    def setup(self):
        self.application = Application.builder().token(self.token).build()
        try:
            self.df_manager.load_data()
        except Exception as e:
            logger.error(f"Errore caricamento dati: {e}")
        self._register_handlers()

    def _register_handlers(self):
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("info", self.info_command))
        self.application.add_handler(CommandHandler("plot", self.plot_command))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_question))
        # Inline buttons handlers (examples + variables)
        self.application.add_handler(CallbackQueryHandler(self.handle_example_callback, pattern=r"^EXAMPLE:.+"))
        self.application.add_handler(CallbackQueryHandler(self.handle_show_vars_callback, pattern=r"^SHOW_VARS$"))

    # ---------- Comandi ----------
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        msg = (
            f"Ciao {user.first_name} ðŸ‘‹\n\n"
            "Sono il bot per esplorare i dati socio-economici comunali ðŸ‡®ðŸ‡¹\n\n"
            "Scrivimi una richiesta, ad esempio:\n"
            "â€¢ `Popolazione Bari e Napoli nel tempo`\n"
            "â€¢ `Reddito medio a Milano 2010-2020`\n"
            "â€¢ `Quota pensionati Roma e Firenze`\n\n"
            "Per altri esempi digita /help ðŸ˜‰"
        )
        await update.message.reply_text(msg, parse_mode=ParseMode.MARKDOWN, reply_markup=inline_kb)
        log_message(user, msg, "RESPONSE", "OUT", query_type="START")

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user = update.effective_user
        msg = HELP_TEXT
        # Inline keyboard with clickable examples and a variables toggle
        examples = [
            ("👥 Popolazione Milano e Roma", "Popolazione Milano e Roma"),
            ("💼 Reddito medio a Torino nel tempo", "Reddito medio Torino nel tempo"),
            ("👩‍🦳 Pensionati Napoli e Milano % popolazione (2015-2023)", "Pensionati Napoli e Milano rispetto alla popolazione 2015-2023"),
            ("📈 Gini index Bari e Palermo", "Gini index Bari e Palermo"),
            ("🎓 Laureati residenti Firenze e Bologna (ultimo anno)", "Laureati residenti Firenze e Bologna ultimo anno"),
        ]
        rows = [[InlineKeyboardButton(text=label, callback_data=f"EXAMPLE:{query}")] for (label, query) in examples]
        rows.append([InlineKeyboardButton(text="🔑 Mostra variabili", callback_data="SHOW_VARS")])
        inline_kb = InlineKeyboardMarkup(rows)
        # Inline keyboard with clickable examples and a variables toggle
        examples = [
            ("👥 Popolazione Milano e Roma", "Popolazione Milano e Roma"),
            ("💼 Reddito medio a Torino nel tempo", "Reddito medio Torino nel tempo"),
            ("👩‍🦳 Pensionati Napoli e Milano % popolazione (2015-2023)", "Pensionati Napoli e Milano rispetto alla popolazione 2015-2023"),
            ("📈 Gini index Bari e Palermo", "Gini index Bari e Palermo"),
            ("🎓 Laureati residenti Firenze e Bologna (ultimo anno)", "Laureati residenti Firenze e Bologna ultimo anno"),
        ]
        rows = [[InlineKeyboardButton(text=label, callback_data=f"EXAMPLE:{query}")] for (label, query) in examples]
        rows.append([InlineKeyboardButton(text="🔑 Mostra variabili", callback_data="SHOW_VARS")])
        inline_kb = InlineKeyboardMarkup(rows)


